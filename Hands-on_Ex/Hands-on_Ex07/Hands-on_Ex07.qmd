---
title: "Hands-on Exercise 7: Visualising and Analysing Geographic Data"
author: "Wei Yanrui"
date: "February 28, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
  warning: false
  message: false
editor: visual
---

# 1. Roadmap for studying

# 2. Visualzing: Choropleth Maps

## 2.1 Overview

**What is Choropleth Maps?**

-   a type of map that uses colors to represent the magnitude of specific data values within certain areas, such as population density, income levels, or any other statistical data.

**Why use Choropleth Maps?**

-   Visual representation: shows the differences in data between geographical areas, allowing one to see at a glance where values are high or low.

-   Easy to understand.

-   Wide application: climate change, economic development, happy index, social issues, and other different fields.

**How does it work?**

-   Each area is filled with a color corresponding to its data value. Higher data values are usually represented by darker colors, while lower data values are represented by lighter colors.

## 2.2 Getting Started

In this hands-on exercise, the key R package use is [tmap](https://cran.r-project.org/web/packages/tmap/) package in R. Beside tmap package, four other R packages will be used. They are:

-   readr for importing delimited text file,
-   tidyr for tidying data,
-   dplyr for wrangling data and
-   [sf](https://cran.r-project.org/web/packages/sf/) for handling geospatial data.

To install and load these packages:

```{r}
pacman::p_load(tidyverse, sf, tmap)
```

## 2.3 Importing Data

### 2.3.1 The Data

Two data set will be used to create the choropleth map. They are:

-   Master Plan 2014 Subzone Boundary (Web) (i.e. `MP14_SUBZONE_WEB_PL`) in ESRI shapefile format. It can be downloaded at [data.gov.sg](https://beta.data.gov.sg/) This is a geospatial data. It consists of the geographical boundary of Singapore at the planning subzone level. The data is based on URA Master Plan 2014.

-   Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format (i.e. `respopagesextod2011to2020.csv`). This is an aspatial data fie. It can be downloaded at [Department of Statistics, Singapore](https://www.singstat.gov.sg/). Although it does not contain any coordinates values, but it’s PA and SZ fields can be used as unique identifiers to geocode to `MP14_SUBZONE_WEB_PL` shapefile.

### 2.3.2 Importing Geospatial Data into R

The code chunk below uses the *st_read()* function of `sf` package to import `MP14_SUBZONE_WEB_PL` shapefile into R as a simple feature data frame called `mpsz`.

**Simple Feature Data Frame**

-   a data structure used for storing and manipulating spatial data.

-   a standard for describing the geometries of spatial data, such as points (locations), lines (paths), polygons (areas), etc.

-   allows data scientists and geographic information specialists to process and analyze geospatial data in a consistent manner across various GIS software and programming environments.

-   Beyond the regular data columns (such as numeric, character, and logical values), a simple feature data frame includes at least one special column (known as the geometry column) that stores the spatial geometry data for each observation which enables the simple feature data frame to directly visualize and analyze spatial data within R, without the dependency on external GIS software.

```{r}
mpsz <- st_read(dsn="data/geospatial",
                layer = "MP14_SUBZONE_WEB_PL")
```

::: {.callout-note icon="false"}
## Code Notes

1.  `dsn`: the data source name or directory where the geospatial files are located.

2.  `layer`: the specific layer within the shapefile

3.  **shapefile**: a popular geospatial vector data format that typically comprises several different files, which together define the attributes and geometric information of a map.\
    3.1 **.shp**: the main file that contains the geospatial geometry data.\
    3.2 **.shx**: the index file, which allows GIS programs to quickly find the geometries of the data.\
    3.3 **.dbf**: the attribute file that contains attribute data associated with each shape, stored in the dBASE format.\
    3.4 **.prf**: the projection file, which describes the coordinate system and projection information used by the geospatial data.
:::

You can examine the content of `mpsz` (first 10 records) by using the code chunk below.

```{r}
mpsz
```

### 2.3.3 Importing Attribute Data into R

Next, we will import *respopagsex2011to2020.csv* file into RStudio and save the file into an R dataframe called *popagsex*.

```{r}
popdata <- read_csv("data/aspatial/respopagesextod2011to2020.csv")
```

### 2.3.4 Data Preparation

Before a thematic map can be prepared, you are required to prepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.

-   YOUNG: age group 0 to 4 until age groyup 20 to 24,
-   ECONOMY ACTIVE: age group 25-29 until age group 60-64,
-   AGED: age group 65 and above,
-   TOTAL: all age group, and
-   DEPENDENCY: the ratio between young and aged against economy active group

#### 2.3.4.1 Data Wrangling

The following data wrangling and transformation functions will be used:

-   *pivot_wider()* of **tidyr** package, and
-   *mutate(), filter(), group_by()* and *select()* of **dplyr** package

```{r}
popdata2020 <- popdata %>%
  filter(Time == 2020) %>%
  group_by(PA,SZ,AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup() %>%
  pivot_wider(names_from=AG,
              values_from=POP) %>%
  mutate(YOUNG=rowSums(.[3:6])
         +rowSums(.[12])) %>%
  mutate(`ECONOMY ACTIVE`=rowSums(.[7:11])
         +rowSums(.[13:15])) %>%
  mutate(`AGED`=rowSums(.[16:21])) %>%
  mutate(`TOTAL`=rowSums(.[3:21])) %>%
  mutate(`DEPENDENCY`=(`YOUNG`+`AGED`)/`ECONOMY ACTIVE`) %>%
  select(`PA`,`SZ`,`YOUNG`,`ECONOMY ACTIVE`,`AGED`,`TOTAL`,`DEPENDENCY`)
```

#### 2.3.4.2 Joining the attribute data and geospatial data

Before we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of *SUBZONE_N* and *PLN_AREA_N* are in uppercase. We need to convert the ones of *PA* and *SZ* to uppercase as well so that they can be matched with *SUBZONE_N* and *PLN_AREA_N*.

```{r}
popdata2020 <- popdata2020 %>%
  mutate_at(.vars = vars(PA,SZ),
            .funs = funs(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

::: {.callout-note icon="false"}
## Code Notes

1.  why `mutate_at()`, not `mutate()`: `mutate_at()` provides a more convenient way to apply the same operation or conversion to multiple columns.

2.  `.vars=vars()`: `.vars` indicates which columns to be selected (could be vector of column name, vector of column index). `vars()` is a select helper enables you to choose multiple columns.

3.  `.funs=funs(toupper)`: `.funs` indicates what function to be used to selected columns. `funs(toupper)` is the function to capitalize all characters.

4.  `filter(`ECONOMY ACTIVE`> 0)`: to remove the rows where `DEPENDENCY` is NaN.
:::

Next, *left_join()* of **dplyr** is used to join the geographical data and attribute table using planning subzone name e.g. *SUBZONE_N* and *SZ* as the common identifier.

```{r}
mpsz_pop2020 <- left_join(mpsz,popdata2020,
                          by=c("SUBZONE_N"="SZ"))
```

::: {.callout-note icon="false"}
## Code Notes

1.  `left_join()`: is used with `mpsz` simple feature data frame as the left data table is to ensure that the output will be a simple features data frame.
:::

To save the R object to directory:

```{r}
write_rds(mpsz_pop2020,"data/rds/mpszpop2020.rds")
```

## 2.4 Plotting Choropleth Maps with *tmap*

Two approaches can be used to prepare thematic map using tmap, they are:

-   Plotting a thematic map quickly by using *qtm()*.
-   Plotting highly customisable thematic map by using tmap elements.

### 2.4.1 Plotting a choropleth map quickly by using *qtm()*

The easiest and quickest to draw a choropleth map using **tmap** is using *qtm()*. It is concise and provides a good default visualisation in many cases.

The code chunk below will draw a cartographic standard choropleth map as shown below.

```{r}
tmap_mode("plot")
qtm(mpsz_pop2020,
    fill="DEPENDENCY")
```

::: {.callout-note icon="false"}
## Code Notes

1.  `tmap_mode()`: is used to set the mode of `tmap`.\
    1.1 "plot" mode: produce a static map.\
    1.2 "view" mode: produce an interactive map.
:::

### 2.4.2 Plotting a choropleth map by using *tmap's elements*

Despite its usefulness of drawing a choropleth map quickly and easily, the disadvantge of *qtm()* is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, **tmap’s drawing elements** should be used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Blues",
          title = "Dependency ratio")+
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE)+
  tm_borders(alpha = 0.5)+
  tm_compass(type="8star", size = 2)+
  tm_scale_bar()+
  tm_grid(alpha = 0.2)+
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS",
             position = c("left","bottom"))
```

::: {.callout-note icon="false"}
## Code Notes

1.  `tm_shape()`: indicates the foundation layer of the map which is the *mpsz_pop2020* dataset.

2.  `tm_fill()`: one filling layer based on *DEPENDENCY* attribute.\
    2.1 `style="quantile"`: indicates the rule of change on color. In this case, the color assignment is based on the quantiles of values of *DEPENDENCY*.\
    2.2 `palette="Blues"`: select a set of blue colors to represent values of *DEPENDENCY*.\
    2.3 `title="..."`: set the title for legend.\

3.  `tm_layout()`: design the overall layout and format of map.\
    3.1 `frame=TRUE`: adds frame line to the map.\

4.  `tm_borders`: border line layer to visually seperate each subzone.\
    4.1 `col=`: border color.\
    4.2 `lwd=`: border line width, default is 1.\
    4.3 `lty=`: border line type, default is "solid".\
    4.4 `alpha=`: border line transparency.\

5.  `tm_compass()`: compass layer to recognize directions.

6.  `tm_scale_bar()`: measuring scale layer.

7.  `tm_grid()`: add grid lines to the map.

8.  `tm_credits()`: add copyright info and data source.
:::

### 2.4.3 Data classification methods of tmap

Most choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes. (different ways to group numerical data into categories or classes.)

**tmap** provides a total ten data classification methods, namely: *fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher*, and *jenks*.

-  **fixed**: Class boundaries are based on specific values you choose.

-  **sd**: Classes are created based on the standard deviation from the mean of the data. This method is useful for data that is normally distributed. If most of your data points are close to the average, they fall into one class, and points far from the average fall into other classes.

-  **equal**: This method divides the range of your data into equal-sized intervals.

-  **pretty (default)**: This method tries to create classes that are easy to understand and are "pretty" or neatly aligned to round numbers. It’s like the equal method but adjusts the class limits to more round numbers.

-  **Quantile**: Each class contains an equal number of data points. If you have 100 data points and you want 5 classes, each class will have 20 data points, regardless of the numerical range they cover.

-  **KMeans**: It tries to group data points into clusters based on their value so that the points in each cluster are as similar as possible.

-  **HClust(Hierarchical Clustering)**: Data is classified based on hierarchical clustering, which creates a tree of clusters. You can then decide where to cut the tree to form classes. It groups data points that are closely related into the same class.

-  **BClust(Birch Clustering)**: Similar to HClust, but specifically uses the Birch clustering algorithm. This method is efficient for large datasets and tries to build a tree structure where the final clusters can be refined to form classes.

-  **Fisher**: this method is often used to reduce the variance within classes and maximize the variance between classes. It's particularly good for data with natural breaks or clusters.

-  **Jenks**: it's focused on finding natural groupings in your data. The Jenks optimization method minimizes variance within classes and maximizes it between classes, ideally highlighting natural groupings or patterns in the data.

To define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.

#### 2.4.3.1 Plotting choropleth maps with built-in classification methods

The code chunk below shows a quantile data classification that used 5 classes.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n=5,
          style="jenks")+
  tm_borders(alpha=0.5)
```

In the code chunk below, *equal* data classification method is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n=5,
          style = "equal")+
  tm_borders(alpha = 0.5)
```

#### 2.4.3.2 Plotting choropleth map with custome break

For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the *breaks* argument to the *tm_fill()*. It is important to note that, in **tmap** the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the *breaks* option (the values must be in increasing order).

Before we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of **DEPENDENCY** field.

```{r}
summary(mpsz_pop2020$DEPENDENCY)
```

With reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00)

Now, we will plot the choropleth map by using the code chunk below.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          breaks = c(0,0.60,0.70,0.80,0.90,1.00))+
  tm_borders(alpha = 0.5)
```

::: {.callout-note icon="false"}
## Code Notes

1.  When you use the *breaks* parameter, you have already explicitly specified how to group the data, so there's no need for the *style* parameter to automatically determine these groups. The *breaks* parameter allows you to precisely control the range of each category, which is very useful when you already know how to group based on specific characteristics or values of the data.

2.  The selected values of *DEPENDENCY* is from 0 to 1. Since the max value is 19, this value will not be displayed in the map, but it doesn't mean any area will not be displayed because one area consists of many values.
:::

### 2.4.4 Colour Scheme

**tmap** supports colour ramps either defined by the user or a set of predefined colour ramps from the **RColorBrewer** package.

#### 2.4.4.1 Using ColourBrewer palette

To change the colour, we assign the preferred colour to *palette* argument of *tm_fill()* as shown in the code chunk below.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n=6,
          style = "quantile",
          palette = "Blues")+
  tm_borders(alpha=0.5)
```

Notice that the choropleth map is shaded in green.

To **reverse** the colour shading, add a “-” prefix.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "-Greens")+
  tm_borders(alpha = 0.5)
```

Notice that the colour scheme has been reversed.

### 2.4.5 Map Layouts

#### 2.4.5.1 Map Legend

In tmap, several *legend* options are provided to change the placement, format and appearance of the legend.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "jenks",
          palette = "Blues",
          legend.hist = TRUE,
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1)+
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone \n(Jenks classification)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.45,
            legend.width = 0.35,
            legend.outside = FALSE,
            legend.position = c("right","bottom"),
            frame = FALSE)+
  tm_borders(alpha=0.5)
```

::: {.callout-note icon="false"}
## Code Notes

1.  `legend.hist=TRUE`: This enables a histogram in the legend, showing the distribution of the data values across the categories defined by the Jenks classification. The histogram provides a visual representation of how many data points fall into each category.


2.  `legend.hist.z=0.1`: This parameter adjusts the z-scale of the histogram in the legend, essentially controlling the height of the bars in the histogram relative to the size of the legend. A value of 0.1 reduces the height, making the histogram bars smaller.

3   `legend.is.portrait=TRUE`: This setting controls the orientation of the legend. Setting it to **TRUE** makes the legend vertical (portrait mode). If it were **FALSE**, the legend would be horizontal (landscape mode).

4.  `legend.height`,`legend.width`: `legend.height` sets the height of the legend relative to the height of the entire map, and `legend.width` sets the width relative to the width of the map. Both are expressed as fractions of the total height and width, so values of 0.45 and 0.35 mean the legend's height is 45% of the map's height, and its width is 35% of the map's width, respectively. (the size of the legend)

5.  `legend.outside=FALSE`: This determines whether the legend should be placed outside the map area. Setting it to **FALSE** keeps the legend inside the main map area. If it were **TRUE**, the legend would be placed outside the map, which could be useful if the map area is crowded or if you want a clearer separation between the map and its legend.

6.  `legend.position=c("right","bottom")`: This sets the position of the legend on the map. (the position of the legend)
:::

#### 2.4.5.2 Map style

tmap allows a wide variety of layout settings to be changed. They can be called by using *tmap_style()*.

The code chunk below shows the *classic* style is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "-Greens")+
  tm_borders(alpha = 0.5)+
  tmap_style("classic")
```

#### 2.4.5.3 Cartographic furniture

Beside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.

In the code chunk below, *tm_compass()*, *tm_scale_bar()* and *tm_grid()* are used to add compass, scale bar and grid lines onto the choropleth map.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Blues",
          title = "No. of persons")+
  tm_layout(main.title = "Distribution of Dependency Ratio \nby planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE)+
  tm_borders(alpha = 0.5)+
  tm_compass(type = "8star", size=2)+
  tm_scale_bar(width=0.15)+
  tm_grid(lwd=0.1,alpha=0.2)+
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorith (URA)\n and Population data from Department of Statistics DOS",
             position = c("left","bottom"))
```

::: {.callout-note icon="false"}
## Code Notes

1.  `tm_credits()`: add a text label on the map, which is often used for attribution, to provide credits for the data source, or to include any other necessary textual information directly on the map visualization. This feature is particularly important for acknowledging sources or providing additional context to the map's viewers.
:::

To reset the default style, refer to the code chunk below.

```{r}
tmap_style("white")
```

### 2.4.6 Drawing Small Multiple Choropleth Maps





### 2.4.7 Plotting a choropleth map

## 2.5

## 2.6

# 3. Visualzing: Geospatial Point Data

# 4. Analyzing: Analytical Mapping

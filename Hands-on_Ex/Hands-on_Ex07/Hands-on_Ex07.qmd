---
title: "Hands-on Exercise 7: Visualising and Analysing Geographic Data"
author: "Wei Yanrui"
date: "February 28, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
  warning: false
  message: false
editor: visual
---

# 1. Roadmap for studying

# 2. Visualzing: Choropleth Maps

## 2.1 Overview

**What is Choropleth Maps?**

-   a type of map that uses colors to represent the magnitude of specific data values within certain areas, such as population density, income levels, or any other statistical data.

**Why use Choropleth Maps?**

-   Visual representation: shows the differences in data between geographical areas, allowing one to see at a glance where values are high or low.

-   Easy to understand.

-   Wide application: climate change, economic development, happy index, social issues, and other different fields.

**How does it work?**

-   Each area is filled with a color corresponding to its data value. Higher data values are usually represented by darker colors, while lower data values are represented by lighter colors.

## 2.2 Getting Started

In this hands-on exercise, the key R package use is [tmap](https://cran.r-project.org/web/packages/tmap/) package in R. Beside tmap package, four other R packages will be used. They are:

-   readr for importing delimited text file,
-   tidyr for tidying data,
-   dplyr for wrangling data and
-   [sf](https://cran.r-project.org/web/packages/sf/) for handling geospatial data.

To install and load these packages:

```{r}
pacman::p_load(tidyverse, sf, tmap)
```

## 2.3 Importing Data

### 2.3.1 The Data

Two data set will be used to create the choropleth map. They are:

-   Master Plan 2014 Subzone Boundary (Web) (i.e. `MP14_SUBZONE_WEB_PL`) in ESRI shapefile format. It can be downloaded at [data.gov.sg](https://beta.data.gov.sg/) This is a geospatial data. It consists of the geographical boundary of Singapore at the planning subzone level. The data is based on URA Master Plan 2014.

-   Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format (i.e. `respopagesextod2011to2020.csv`). This is an aspatial data fie. It can be downloaded at [Department of Statistics, Singapore](https://www.singstat.gov.sg/). Although it does not contain any coordinates values, but it’s PA and SZ fields can be used as unique identifiers to geocode to `MP14_SUBZONE_WEB_PL` shapefile.

### 2.3.2 Importing Geospatial Data into R

The code chunk below uses the *st_read()* function of `sf` package to import `MP14_SUBZONE_WEB_PL` shapefile into R as a simple feature data frame called `mpsz`.

**Simple Feature Data Frame**

-   a data structure used for storing and manipulating spatial data.

-   a standard for describing the geometries of spatial data, such as points (locations), lines (paths), polygons (areas), etc.

-   allows data scientists and geographic information specialists to process and analyze geospatial data in a consistent manner across various GIS software and programming environments.

-   Beyond the regular data columns (such as numeric, character, and logical values), a simple feature data frame includes at least one special column (known as the geometry column) that stores the spatial geometry data for each observation which enables the simple feature data frame to directly visualize and analyze spatial data within R, without the dependency on external GIS software.

```{r}
mpsz <- st_read(dsn="data/geospatial",
                layer = "MP14_SUBZONE_WEB_PL")
```

::: {.callout-note icon="false"}
## Code Notes

1.  `dsn`: the data source name or directory where the geospatial files are located.

2.  `layer`: the specific layer within the shapefile

3.  **shapefile**: a popular geospatial vector data format that typically comprises several different files, which together define the attributes and geometric information of a map.\
    3.1 **.shp**: the main file that contains the geospatial geometry data.\
    3.2 **.shx**: the index file, which allows GIS programs to quickly find the geometries of the data.\
    3.3 **.dbf**: the attribute file that contains attribute data associated with each shape, stored in the dBASE format.\
    3.4 **.prf**: the projection file, which describes the coordinate system and projection information used by the geospatial data.
:::

You can examine the content of `mpsz` (first 10 records) by using the code chunk below.

```{r}
mpsz
```

### 2.3.3 Importing Attribute Data into R

Next, we will import *respopagsex2011to2020.csv* file into RStudio and save the file into an R dataframe called *popagsex*.

```{r}
popdata <- read_csv("data/aspatial/respopagesextod2011to2020.csv")
```

### 2.3.4 Data Preparation

Before a thematic map can be prepared, you are required to prepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.

-   YOUNG: age group 0 to 4 until age groyup 20 to 24,
-   ECONOMY ACTIVE: age group 25-29 until age group 60-64,
-   AGED: age group 65 and above,
-   TOTAL: all age group, and
-   DEPENDENCY: the ratio between young and aged against economy active group

#### 2.3.4.1 Data Wrangling

The following data wrangling and transformation functions will be used:

-   *pivot_wider()* of **tidyr** package, and
-   *mutate(), filter(), group_by()* and *select()* of **dplyr** package

```{r}
popdata2020 <- popdata %>%
  filter(Time == 2020) %>%
  group_by(PA,SZ,AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup() %>%
  pivot_wider(names_from=AG,
              values_from=POP) %>%
  mutate(YOUNG=rowSums(.[3:6])
         +rowSums(.[12])) %>%
  mutate(`ECONOMY ACTIVE`=rowSums(.[7:11])
         +rowSums(.[13:15])) %>%
  mutate(`AGED`=rowSums(.[16:21])) %>%
  mutate(`TOTAL`=rowSums(.[3:21])) %>%
  mutate(`DEPENDENCY`=(`YOUNG`+`AGED`)/`ECONOMY ACTIVE`) %>%
  select(`PA`,`SZ`,`YOUNG`,`ECONOMY ACTIVE`,`AGED`,`TOTAL`,`DEPENDENCY`)
```

#### 2.3.4.2 Joining the attribute data and geospatial data

Before we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of *SUBZONE_N* and *PLN_AREA_N* are in uppercase. We need to convert the ones of *PA* and *SZ* to uppercase as well so that they can be matched with *SUBZONE_N* and *PLN_AREA_N*.

```{r}
popdata2020 <- popdata2020 %>%
  mutate_at(.vars = vars(PA,SZ),
            .funs = funs(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

::: {.callout-note icon="false"}
## Code Notes

1.  why `mutate_at()`, not `mutate()`: `mutate_at()` provides a more convenient way to apply the same operation or conversion to multiple columns.

2.  `.vars=vars()`: `.vars` indicates which columns to be selected (could be vector of column name, vector of column index). `vars()` is a select helper enables you to choose multiple columns.

3.  `.funs=funs(toupper)`: `.funs` indicates what function to be used to selected columns. `funs(toupper)` is the function to capitalize all characters.

4.  `filter(`ECONOMY ACTIVE`> 0)`: to remove the rows where `DEPENDENCY` is NaN.
:::

Next, *left_join()* of **dplyr** is used to join the geographical data and attribute table using planning subzone name e.g. *SUBZONE_N* and *SZ* as the common identifier.

```{r}
mpsz_pop2020 <- left_join(mpsz,popdata2020,
                          by=c("SUBZONE_N"="SZ"))
```

::: {.callout-note icon="false"}
## Code Notes

1.  `left_join()`: is used with `mpsz` simple feature data frame as the left data table is to ensure that the output will be a simple features data frame.
:::

To save the R object to directory:

```{r}
write_rds(mpsz_pop2020,"data/rds/mpszpop2020.rds")
```

## 2.4 Plotting Choropleth Maps with *tmap*

Two approaches can be used to prepare thematic map using tmap, they are:

-   Plotting a thematic map quickly by using *qtm()*.
-   Plotting highly customisable thematic map by using tmap elements.

### 2.4.1 Plotting a choropleth map quickly by using *qtm()*

The easiest and quickest to draw a choropleth map using **tmap** is using *qtm()*. It is concise and provides a good default visualisation in many cases.

The code chunk below will draw a cartographic standard choropleth map as shown below.

```{r}
tmap_mode("plot")
qtm(mpsz_pop2020,
    fill="DEPENDENCY")
```

::: {.callout-note icon="false"}
## Code Notes

1.  `tmap_mode()`: is used to set the mode of `tmap`.\
    1.1 "plot" mode: produce a static map.\
    1.2 "view" mode: produce an interactive map.
:::

### 2.4.2 Plotting a choropleth map by using *tmap's elements*

Despite its usefulness of drawing a choropleth map quickly and easily, the disadvantge of *qtm()* is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, **tmap’s drawing elements** should be used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Blues",
          title = "Dependency ratio")+
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE)+
  tm_borders(alpha = 0.5)+
  tm_compass(type="8star", size = 2)+
  tm_scale_bar()+
  tm_grid(alpha = 0.2)+
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS",
             position = c("left","bottom"))
```

::: {.callout-note icon="false"}
## Code Notes

1.  `tm_shape()`: indicates the foundation layer of the map which is the *mpsz_pop2020* dataset.

2.  `tm_fill()`: one filling layer based on *DEPENDENCY* attribute.\
    2.1 `style="quantile"`: indicates the rule of change on color. In this case, the color assignment is based on the quantiles of values of *DEPENDENCY*.\
    2.2 `palette="Blues"`: select a set of blue colors to represent values of *DEPENDENCY*.\
    2.3 `title="..."`: set the title for legend.\

3.  `tm_layout()`: design the overall layout and format of map.\
    3.1 `frame=TRUE`: adds frame line to the map.\

4.  `tm_borders`: border line layer to visually seperate each subzone.\
    4.1 `col=`: border color.\
    4.2 `lwd=`: border line width, default is 1.\
    4.3 `lty=`: border line type, default is "solid".\
    4.4 `alpha=`: border line transparency.\

5.  `tm_compass()`: compass layer to recognize directions.

6.  `tm_scale_bar()`: measuring scale layer.

7.  `tm_grid()`: add grid lines to the map.

8.  `tm_credits()`: add copyright info and data source.
:::

### 2.4.3 Data classification methods of tmap

Most choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes. (different ways to group numerical data into categories or classes.)

**tmap** provides a total ten data classification methods, namely: *fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher*, and *jenks*.

-   **fixed**: Class boundaries are based on specific values you choose.

-   **sd**: Classes are created based on the standard deviation from the mean of the data. This method is useful for data that is normally distributed. If most of your data points are close to the average, they fall into one class, and points far from the average fall into other classes.

-   **equal**: This method divides the range of your data into equal-sized intervals.

-   **pretty (default)**: This method tries to create classes that are easy to understand and are "pretty" or neatly aligned to round numbers. It’s like the equal method but adjusts the class limits to more round numbers.

-   **Quantile**: Each class contains an equal number of data points. If you have 100 data points and you want 5 classes, each class will have 20 data points, regardless of the numerical range they cover.

-   **KMeans**: It tries to group data points into clusters based on their value so that the points in each cluster are as similar as possible.

-   **HClust(Hierarchical Clustering)**: Data is classified based on hierarchical clustering, which creates a tree of clusters. You can then decide where to cut the tree to form classes. It groups data points that are closely related into the same class.

-   **BClust(Birch Clustering)**: Similar to HClust, but specifically uses the Birch clustering algorithm. This method is efficient for large datasets and tries to build a tree structure where the final clusters can be refined to form classes.

-   **Fisher**: this method is often used to reduce the variance within classes and maximize the variance between classes. It's particularly good for data with natural breaks or clusters.

-   **Jenks**: it's focused on finding natural groupings in your data. The Jenks optimization method minimizes variance within classes and maximizes it between classes, ideally highlighting natural groupings or patterns in the data.

To define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.

#### 2.4.3.1 Plotting choropleth maps with built-in classification methods

The code chunk below shows a quantile data classification that used 5 classes.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n=5,
          style="jenks")+
  tm_borders(alpha=0.5)
```

In the code chunk below, *equal* data classification method is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n=5,
          style = "equal")+
  tm_borders(alpha = 0.5)
```

#### 2.4.3.2 Plotting choropleth map with custome break

For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the *breaks* argument to the *tm_fill()*. It is important to note that, in **tmap** the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the *breaks* option (the values must be in increasing order).

Before we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of **DEPENDENCY** field.

```{r}
summary(mpsz_pop2020$DEPENDENCY)
```

With reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our breaks vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00)

Now, we will plot the choropleth map by using the code chunk below.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          breaks = c(0,0.60,0.70,0.80,0.90,1.00))+
  tm_borders(alpha = 0.5)
```

::: {.callout-note icon="false"}
## Code Notes

1.  When you use the *breaks* parameter, you have already explicitly specified how to group the data, so there's no need for the *style* parameter to automatically determine these groups. The *breaks* parameter allows you to precisely control the range of each category, which is very useful when you already know how to group based on specific characteristics or values of the data.

2.  The selected values of *DEPENDENCY* is from 0 to 1. Since the max value is 19, this value will not be displayed in the map, but it doesn't mean any area will not be displayed because one area consists of many values.
:::

### 2.4.4 Colour Scheme

**tmap** supports colour ramps either defined by the user or a set of predefined colour ramps from the **RColorBrewer** package.

#### 2.4.4.1 Using ColourBrewer palette

To change the colour, we assign the preferred colour to *palette* argument of *tm_fill()* as shown in the code chunk below.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          n=6,
          style = "quantile",
          palette = "Blues")+
  tm_borders(alpha=0.5)
```

Notice that the choropleth map is shaded in green.

To **reverse** the colour shading, add a “-” prefix.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "-Greens")+
  tm_borders(alpha = 0.5)
```

Notice that the colour scheme has been reversed.

### 2.4.5 Map Layouts

#### 2.4.5.1 Map Legend

In tmap, several *legend* options are provided to change the placement, format and appearance of the legend.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "jenks",
          palette = "Blues",
          legend.hist = TRUE,
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1)+
  tm_layout(main.title = "Distribution of Dependency Ratio by planning subzone \n(Jenks classification)",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.45,
            legend.width = 0.35,
            legend.outside = FALSE,
            legend.position = c("right","bottom"),
            frame = FALSE)+
  tm_borders(alpha=0.5)
```

::: {.callout-note icon="false"}
## Code Notes

1.  `legend.hist=TRUE`: This enables a histogram in the legend, showing the distribution of the data values across the categories defined by the Jenks classification. The histogram provides a visual representation of how many data points fall into each category.

2.  `legend.hist.z=0.1`: This parameter adjusts the z-scale of the histogram in the legend, essentially controlling the height of the bars in the histogram relative to the size of the legend. A value of 0.1 reduces the height, making the histogram bars smaller.

3 `legend.is.portrait=TRUE`: This setting controls the orientation of the legend. Setting it to **TRUE** makes the legend vertical (portrait mode). If it were **FALSE**, the legend would be horizontal (landscape mode).

4.  `legend.height`,`legend.width`: `legend.height` sets the height of the legend relative to the height of the entire map, and `legend.width` sets the width relative to the width of the map. Both are expressed as fractions of the total height and width, so values of 0.45 and 0.35 mean the legend's height is 45% of the map's height, and its width is 35% of the map's width, respectively. (the size of the legend)

5.  `legend.outside=FALSE`: This determines whether the legend should be placed outside the map area. Setting it to **FALSE** keeps the legend inside the main map area. If it were **TRUE**, the legend would be placed outside the map, which could be useful if the map area is crowded or if you want a clearer separation between the map and its legend.

6.  `legend.position=c("right","bottom")`: This sets the position of the legend on the map. (the position of the legend)
:::

#### 2.4.5.2 Map style

tmap allows a wide variety of layout settings to be changed. They can be called by using *tmap_style()*.

The code chunk below shows the *classic* style is used.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "-Greens")+
  tm_borders(alpha = 0.5)+
  tmap_style("classic")
```

#### 2.4.5.3 Cartographic furniture

Beside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.

In the code chunk below, *tm_compass()*, *tm_scale_bar()* and *tm_grid()* are used to add compass, scale bar and grid lines onto the choropleth map.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Blues",
          title = "No. of persons")+
  tm_layout(main.title = "Distribution of Dependency Ratio \nby planning subzone",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE)+
  tm_borders(alpha = 0.5)+
  tm_compass(type = "8star", size=2)+
  tm_scale_bar(width=0.15)+
  tm_grid(lwd=0.1,alpha=0.2)+
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorith (URA)\n and Population data from Department of Statistics DOS",
             position = c("left","bottom"))
```

::: {.callout-note icon="false"}
## Code Notes

1.  `tm_credits()`: add a text label on the map, which is often used for attribution, to provide credits for the data source, or to include any other necessary textual information directly on the map visualization. This feature is particularly important for acknowledging sources or providing additional context to the map's viewers.
:::

To reset the default style, refer to the code chunk below.

```{r}
tmap_style("white")
```

### 2.4.6 Drawing Small Multiple Choropleth Maps

**Small multiple maps**, also referred to as **facet maps**, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.

In **tmap**, small multiple maps can be plotted in three ways:

-   by assigning multiple values to at least one of the asthetic arguments,
-   by defining a group-by variable in *tm_facets()*, and
-   by creating multiple stand-alone maps with *tmap_arrange()*.

#### 2.4.6.1 By assigning multiple values to at least one of the aesthetic arguments

In this example, small multiple choropleth maps are created by defining **ncols** in **tm_fill()**.

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill(c("YOUNG","AGED"),
          style="equal",
          palette="Blues")+
  tm_layout(legend.position=c("right","bottom"))+
  tm_borders(alpha=0.5)+
  tmap_style("white")
```

In this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments.

```{r}
tm_shape(mpsz_pop2020)+
  tm_polygons(c("DEPENDENCY","AGED"),
              style=c("equal","quantile"),
              palette=list("Blues","Greens"))+
  tm_layout(legend.position = c("right","bottom"))
```

::: {.callout-note icon="false"}
## Code Notes

1.  Both `tm_fill` and `tm_polygons` can be used for filling areas on maps, but `tm_polygons` offers more control over the style of boundaries, making it more suitable for scenarios where it's important to emphasize geographical borders. On the other hand, `tm_fill` focuses more on representing data through the color filling of areas, applicable to scenarios that require highlighting data differences rather than the clarity of borders. In practice, these two functions can be combined to achieve both the differentiation of data and the emphasis on geographical boundaries.
:::

#### 2.4.6.2 By defining a group-by variable in *tm_facets()*

In this example, multiple small choropleth maps are created by using *tm_facets()*

```{r}
tm_shape(mpsz_pop2020)+
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Blues",
          thres.poly = 0)+
  tm_facets(by="REGION_N",
            free.coords = TRUE,
            drop.shapes = FALSE)+
  tm_layout(legend.show = FALSE,
            title.position = c("center","center"),
            title.size = 20)+
  tm_borders(alpha = 0.5)
```

::: {.callout-note icon="false"}
## Code Notes

1.  `thres.poly = 0`: is used to set a threshold applied when drawing polygons. Here, it is set to 0, meaning that no polygons will be filtered out based on their size.

2.  `free.coords=TRUE`: indicates that each panel can have its own coordinate axis range, allowing for the optimal display of each region.

3.  `drop.shapes=FALSE`: means that even if some regions do not have data in the *REGION_N* classification, their shapes will not be removed from the map.
:::

#### 2.4.6.3 By creating multiple stand-alone maps with *tmap_arrange()*

In this example, multiple small choropleth maps are created by creating multiple stand-alone maps with *tmap_arrange()*

```{r}
youngmap <- tm_shape(mpsz_pop2020)+
  tm_polygons("YOUNG",
              style="quantile",
              palette="Blues")

agedmap <- tm_shape(mpsz_pop2020)+
  tm_polygons("AGED",
              style="quantile",
              palette="Blues")

tmap_arrange(youngmap,agedmap,asp=1, ncol=2)
```

::: {.callout-note icon="false"}
## Code Notes

1.  `asp=1`: sets the aspect ratio (width/height) of each map in the arrangement. An aspect ratio of 1 means that the height and width of each map are equal, leading to a square shape for each map plot.

2.  `ncol=2`: specifies the number of columns in the arrangement. Setting ncol=2 means that the maps will be arranged side by side in two columns.
:::

### 2.4.7 Mappping Spatial Object Meeting a Selection Criterion

Instead of creating small multiple choropleth map, you can also use selection funtion to map spatial objects meeting the selection criterion.

```{r}
tm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N=="CENTRAL REGION",])+
  tm_fill("DEPENDENCY",
          style="quantile",
          palette = "Blues",
          legend.hist = TRUE,
          legend.is.portrait = TRUE,
          legend.hist.z = 0.1)+
  tm_layout(legend.outside = TRUE,
            legend.height = 0.45,
            legend.width = 5.0,
            legend.position = c("right","bottom"),
            frame = FALSE)+
  tm_borders(alpha=0.5)
```

::: {.callout-note icon="false"}
## Code Notes

1.  `[mpsz_pop2020$REGION_N=="CENTRAL REGION", ]`: \[row constraints, col constraints\], in this case, it filters all the cols corresponding to the constrained rows.
:::

# 3. Visualzing: Geospatial Point Data

Proportional symbol maps (also known as graduate symbol maps) are a class of maps that use the visual variable of size to represent differences in the magnitude of a discrete, abruptly changing phenomenon, e.g. counts of people. Like choropleth maps, you can create classed or unclassed versions of these maps.

-   the classed ones are known as range-graded or graduated symbols
-   the unclassed are called proportional symbols, where the area of the symbols are proportional to the values of the attribute being mapped

In this hands-on exercise, you will learn how to create a **proportional symbol map** showing the number of wins by Singapore Pools’ outlets using an R package called **tmap**.

## 3.1 Getting Started

```{r}
pacman::p_load(sf,tmap,tidyverse)
```

## 3.2 Data Wrangling

### 3.2.1 The Data

The data set use for this hands-on exercise is called SGPools_svy21. The data is in csv file format.

### 3.2.2 Data Import and Preparation

```{r}
sgpools <- read_csv("data/aspatial/SGPools_svy21.csv")
```

It consists of seven columns. The XCOORD and YCOORD columns are the x-coordinates and y-coordinates of SingPools outlets and branches.

After importing the data file into R, it is important for us to examine if the data file has been imported correctly.

The code chunk below shows *list()* is used to do the job.

```{r}
list(sgpools)
```

Notice that the sgpools data in tibble data frame and not the common R data frame.

### 3.2.3 Create a sf data frame from an aspatial data frame

The code chunk below converts sgpools data frame into a simple feature data frame by using *st_as_sf()* of **sf** packages

```{r}
sgpools_sf <- st_as_sf(sgpools,
                    coords = c("XCOORD","YCOORD"),
                    crs=3414)
```

Notice that a new column called *geometry* has been added into the data frame *sgpools_sf*.

::: {.callout-note icon="false"}
## Code Notes

1.  `coords=`: requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.

2.  `crs=`: requires you to provide the coordinates system in epsg format. [EPSG: 3414](https://epsg.io/3414) is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by refering to [epsg.io](https://epsg.io/).
:::

You can display the basic information of the newly created sgpools_sf by using the code chunk below.

```{r}
list(sgpools_sf)
```

::: {.callout-note icon="false"}
## Code Notes

1.  **Geometry type: POINT**: shows that sgppols_sf is in point feature class. It’s epsg ID is 3414. The bbox provides information of the extend of the geospatial data.
:::

## 3.3 Drawing Proportional Symbol Map

To create an interactive proportional symbol map in R, the view mode of tmap will be used.

The code churn below will turn on the interactive mode of tmap.

```{r}
tmap_mode("view")
```

### 3.3.1 Start with an interactive point symbol map (points with same size)

The code chunks below are used to create an interactive point symbol map.

```{r}
tm_shape(sgpools_sf)+
  tm_bubbles(col="red",
             size=1,
             border.col="black",
             border.lwd=1)
```

::: {.callout-note icon="false"}
## Code Notes

1.  `col="red"`: fills the colour of points in red.

2.  `size=1`: defines the size of points.

3.  `border.col = "black"`: fills the border line of points in black.

4.  `border.lwd=1`: defines the width of border line of points.
:::

### 3.3.2 Make it proportional (points with different size)

To draw a proportional symbol map, we need to assign a numerical variable to the size visual attribute. The code chunks below show that the variable *Gp1Gp2Winnings* is assigned to size visual attribute.

```{r}
tm_shape(sgpools_sf)+
  tm_bubbles(col="red",
             size="Gp1Gp2 Winnings",
             border.col="black",
             border.lwd=1)
```

### 3.3.3 Give it a different colour

The proportional symbol map can be further improved by using the colour visual attribute. In the code chunks below, *OUTLET_TYPE* variable is used as the colour attribute variable.

```{r}
tm_shape(sgpools_sf)+
  tm_bubbles(col="OUTLET TYPE",
             size="Gp1Gp2 Winnings",
             border.col="black",
             border.lwd=1)
```

::: {.callout-note icon="false"}
## Code Notes

1.  `col="OUTLET TYPE"`: assigns different colours to different outlet type variable.
:::

### 3.3.4 Have a twin maps

An impressive and little-know feature of tmap’s view mode is that it also works with [faceted plots]{.underline}. The argument *sync* in *tm_facets()* can be used in this case to produce multiple maps [with synchronised zoom and pan settings]{.underline}.

```{r}
tm_shape(sgpools_sf)+
  tm_bubbles(col="OUTLET TYPE",
             size="Gp1Gp2 Winnings",
             border.col="black",
             border.lwd=1)+
  tm_facets(by="OUTLET TYPE",
            nrow=1,
            sync = TRUE)
```

# 4. Analyzing: Analytical Mapping

## 4.1 Getting Started

### 4.1.1 Installing and loading packages

```{r}
pacman::p_load(sf, tmap, tidyverse)
```

### 4.1.2 Importing data

For the purpose of this hands-on exercise, a prepared data set called *NGA_wp.rds* will be used. The data set is a polygon feature data.frame providing information on water point of Nigeria at the LGA level. You can find the data set in the rds sub-direct of the hands-on data folder.

-  Simple Feature Dataframe: provides a flexible way to handle various types of spatial data

-  Polygon Feature Dataframe: offers a focused approach for processing and analyzing polygon spatial data.

```{r}
NGA_wp <- read_rds("data/rds/NGA_wp.rds")
```

## 4.2 Analyzing: Basic Choropleth Mapping

### 4.2.1 Visualizing distribution of functional water point

Plot a choropleth map showing the distribution of function water point by LGA.

```{r}
tmap_mode("plot")

p1 <- tm_shape(NGA_wp)+
  tm_fill("wp_functional",
          n=10,
          style = "equal",
          palette = "Blues")+
  tm_borders(lwd=0.1,
             alpha = 1)+
  tm_layout(main.title = "Distribution of functional water point by LGAs",
            legend.outside = FALSE)

p2 <- tm_shape(NGA_wp)+
  tm_fill("total_wp",
          n=10,
          style = "equal",
          palette = "Blues")+
  tm_borders(lwd=0.1,
             alpha = 1)+
  tm_layout(main.title = "Distribution of total water point by LGAs",
            legend.outside = FALSE)

tmap_arrange(p2,p1,nrow=1)
```

## 4.3 Analyzing: Choropleth Map for Rates

### 4.3.1 Deriving Proportion of Functional Water Points and Non-Functional Water Points

We will tabulate the proportion of functional water points and the proportion of non-functional water points in each LGA. In the following code chunk, `mutate()` from **dplyr** package is used to derive two fields, namely *pct_functional* and *pct_nonfunctional*.

```{r}
NGA_wp <- NGA_wp %>%
  mutate(pct_functional = wp_functional / total_wp) %>%
  mutate(pct_nonfunctional = wp_nonfunctional / total_wp)
```

### 4.3.2 Plotting map of rate

Plot a choropleth map showing the distribution of percentage functional water point by LGA.

```{r}
tm_shape(NGA_wp)+
  tm_fill("pct_functional",
          n=10,
          style = "equal",
          palette = "Blues",
          legend.hist = TRUE)+
  tm_borders(lwd=0.1,
             alpha = 1)+
  tm_layout(main.title = "Rate map of functional water point by LGAs",
            legend.outside = TRUE)
```

## 4.4 Analyzing: Extreme Value Maps

### 4.4.1 Percentile Map

#### 4.4.1.1 Data Preparation

#### 4.4.1.2 Creating the get.var function

#### 4.4.1.3 A percentile mapping function

#### 4.4.1.4 Test drive the percentile mapping function

### 4.4.2 Box Map

#### 4.4.2.1 Creating the boxbreaks function

#### 4.4.2.2 Creating the grt.var function

#### 4.4.2.3 Test drive the newly created function

#### 4.4.2.4 Boxmap function

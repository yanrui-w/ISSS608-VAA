---
title: "Hands-on Exercise 8: Network Data Visualisation and Analysis"
author: "Wei Yanrui"
date: "March 5, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
  warning: false
  message: false
editor: visual
---

# 1. Roadmap for studying

![]()

# 2. Getting Started

## 2.1 Installing and launching R packages

In this hands-on exercise, four network data modelling and visualisation packages will be installed and launched. They are **igraph, tidygraph, ggraph** and **visNetwork**. Beside these four packages, **tidyverse** and **lubridate**, an R package specially designed to handle and wrangling time data will be installed and launched too.

```{r}
pacman::p_load(igraph,tidygraph,ggraph,
               visNetwork,lubridate,clock,
               tidyverse,graphlayouts)
```

# 3. The Data

The data sets used in this hands-on exercise is from an oil exploration and extraction company. There are two data sets. One contains the nodes data and the other contains the edges (also know as link) data.

-   **Nodes Data**: Points or dots in a network which can represent almost anything, depending on what the network is about. Nodes data is essentially information about these points, such as their names, characteristics, and possibly their positions in space if the network has a geographical component.
-   **Edges Data**: Lines that connect the nodes in a network, showing how they are related. Edges data includes information about these connections, like the type of relationship (friendship, road, data link, etc.), the strength or capacity of the connection (like the bandwidth of an internet connection), and sometimes the distance or cost associated with the connection.

## 3.1 The edges data

*GAStech-email_edges-v2.csv* which consists of two weeks of 9063 emails correspondances between 55 employees.

![edgesdata](image/edgesdata.png)

## 3.2 The nodes data

*GAStech_email_nodes.csv* which consist of the names, department and title of the 55 employees.

![nodesdata](image/nodesdata.png)

## 3.3 Importing network data from files

Import *GAStech_email_node.csv* and *GAStech_email_edges-v2.csv* into RStudio environment by using `read_csv()` of readr package.

```{r}
GAStech_nodes <- read_csv("data/GAStech_email_node.csv")
GAStech_edges <- read_csv("data/GAStech_email_edge-v2.csv")
```

## 3.4 Reviewing the imported data

Next, we will examine the structure of the data frame using `glimpse()` of **dplyr**.

```{r}
glimpse(GAStech_edges)
```

::: {.callout-note icon="false"}
## Warning

The output report of *GAStech_edges* above reveals that the *SentDate* is treated as “Character” data type instead of date data type. This is an error! Before we continue, it is important for us to change the data type of SentDate field back to “Date” data type.
:::

## 3.5 Wrangling time

The code chunk below will be used to perform the changes.

```{r}
GAStech_edges <- GAStech_edges %>%
  mutate(SentDate = dmy(SentDate)) %>%
  mutate(Weekday=wday(SentDate,
                      label=TRUE,
                      abbr=FALSE))
```

::: {.callout-note icon="false"}
## Code Notes

1.  `dmy()`: a function of **lubridate** package which transforms the *SentDate* to Date data type.

2.  `wday()`: a function of **lubridate** package which returns the day of the week as a decimal number or an ordered factor if label is TRUE. The argument abbr is FALSE keep the daya spells in full, i.e. Monday. The function will create a new column in the data.frame i.e. *Weekday* and the output of `wday()` will save in this newly created field. The values in the Weekday field are in ordinal scale.
:::

## 3.6 Reviewing the revised data fields

Table below shows the data structure of the reformatted GAStech_edges data frame.

```{r}
glimpse(GAStech_edges)
```

## 3.7 Wrangling attributes

A close examination of GAStech_edges data.frame reveals that it consists of individual e-mail flow records. This is not very useful for visualisation.

In view of this, we will aggregate the individual by date, senders, receivers, main subject and day of the week.

The code chunk:

```{r}
GAStech_edges_aggregated <- GAStech_edges %>%
  filter(MainSubject == "Work related") %>%
  group_by(source,target,Weekday) %>%
  summarise(Weight=n()) %>%
  filter(source!=target) %>%
  filter(Weight>1) %>%
  ungroup()
```

## 3.8 Reviewing the revised edges file

Table below shows the data structure of the reformatted *GAStech_edges_aggregated* data frame.

```{r}
glimpse(GAStech_edges_aggregated)
```

# 4. Creating network objects using tidygraph

In this section, **tidygraph** packageyou will be used to create a graph data model. It provides a tidy API for graph/network manipulation. While network data itself is not tidy, it can be envisioned as two tidy tables, one for node data and one for edge data. tidygraph provides a way to switch between the two tables and provides dplyr verbs for manipulating them. Furthermore it provides access to a lot of graph algorithms with return values that facilitate their use in a tidy workflow.

Refer to these two articles for more information:\
- [Introducing tidygraph](https://www.data-imaginist.com/posts/2017-07-07-introducing-tidygraph/)\
- [tidygraph 1.1 - A tidy hope](https://www.data-imaginist.com/posts/2018-02-12-tidygraph-1-1-a-tidy-hope/index.html)

## 4.1 The tbl_graph object

Two functions of **tidygraph** package can be used to create network objects, they are:

-   `tbl_graph()` creates a new **tbl_graph** network object from nodes and edges data.

-   `as_tbl_graph()` converts an existed network data and objects to a **tbl_graph** network. Below are network data and objects supported by `as_tbl_graph()`

    -   a node data.frame and an edge data.frame,

    -   data.frame, list, matrix from base,

    -   igraph from igraph, - network from network,

    -   dendrogram and hclust from stats,

    -   Node from data.tree,

    -   phylo and evonet from ape, and

    -   graphNEL, graphAM, graphBAM from graph (in Bioconductor).

## 4.2 The dplyr verbs in tidygraph

-   `activate()` verb from **tidygraph** serves as a switch between tibbles for nodes and edges. All dplyr verbs applied to **tbl_graph** object are applied to the active tibble.

-   `N()` function is used to gain access to the node data while manipulating the edge data. Similarly .`E()` will give you the edge data and .`G()` will give you the tbl_graph object itself.

## 4.3 Using tbl_graph() to build tidygraph data model

In this section, `tbl_graph()` of **tidygraph** package will be used to build an tidygraph’s network graph data.frame.

Before typing the codes, it's recommended to review to reference guide of [tbl_graph()](https://tidygraph.data-imaginist.com/reference/tbl_graph.html)

```{r}
GAStech_graph <- tbl_graph(nodes=GAStech_nodes,
                           edges=GAStech_edges_aggregated,
                           directed =TRUE)
```

::: {.callout-note icon="false"}
## Code Notes

1.  `directed=TRUE`: directed graph where edges have directions.
:::

## 4.4 Reviewing the output tidygraph's graph object

```{r}
GAStech_graph
```

## 4.5 Changing the active object

The nodes tibble data frame is activated by default, but you can change which tibble data frame is active with the `activate()` function. Thus, if we wanted to rearrange the rows in the edges tibble to list those with the highest *weight* first, we could use `activate()` and then `arrange()`.

The notion of an active tibble within a tbl_graph object makes it possible to manipulate the data in one tibble at a time.

For example,

```{r}
GAStech_graph %>%
  activate(edges) %>%
  arrange(desc(Weight))
```

Visit the reference guide of [activate()](https://tidygraph.data-imaginist.com/reference/activate.html) to find out more about the function.

# 5. Plotting Static Network Graphs with ggraph package

[ggraph](https://ggraph.data-imaginist.com/) is an extension of **ggplot2**, making it easier to carry over basic ggplot skills to the design of network graphs.

As in all network graph, there are three main aspects to a **ggraph**’s network graph, they are:

-   [nodes](https://cran.r-project.org/web/packages/ggraph/vignettes/Nodes.html),
-   [edges](https://cran.r-project.org/web/packages/ggraph/vignettes/Edges.html) and
-   [layouts](https://cran.r-project.org/web/packages/ggraph/vignettes/Layouts.html)

## 5.1 Plotting a basic network graph

The code chunk below uses [ggraph()](https://ggraph.data-imaginist.com/reference/ggraph.html), [geom-edge_link()](https://ggraph.data-imaginist.com/reference/geom_edge_link.html) and [geom_node_point()](https://ggraph.data-imaginist.com/reference/geom_node_point.html) to plot a network graph by using *GAStech_graph*. Before getting started, it is advisable to read their respective reference guide at least once.

```{r}
ggraph(GAStech_graph)+
  geom_edge_link()+
  geom_node_point()
```

::: {.callout-note icon="false"}
## Code Notes

1.  `ggraph()`: has two key arguments: data and layout. `ggraph()` can use either an igraph object or a tbl_graph object. Layout decides the way to display nodes and edges.

2.  `geom_edge_link()`: a layer used to draw the links between nodes.

3.  `geom_node_point()`: a layer used to draw the nodes.
:::

## 5.2 Changing the default network graph theme

In this section, you will use [theme_graph()](https://ggraph.data-imaginist.com/reference/theme_graph.html) to remove the x and y axes.

```{r}
g <- ggraph(GAStech_graph)+
  geom_edge_link(aes())+
  geom_node_point(aes())

g+theme_graph()
```

::: {.callout-note icon="false"}
## Code Notes

1.  `theme_graph()`: **ggraph** introduces a special ggplot theme that provides better defaults for network graphs than the normal ggplot defaults. `theme_graph()`, besides removing axes, grids, and border, changes the font to Arial Narrow (this can be overridden).

-   The ggraph theme can be set for a series of plots with the `set_graph_style()` command run before the graphs are plotted or by using `theme_graph()` in the individual plots.
:::

## 5.3 Changing the coloring of the plot

Furthermore, `theme_graph()` makes it easy to change the coloring of the plot.

```{r}
g <- ggraph(GAStech_graph)+
  geom_edge_link(aes(colour="grey50"))+
  geom_node_point(aes(colour="grey40"))

g+theme_graph(background = "grey10",
              text_colour = "white")
```

## 5.4 Working with ggraph's layouts

**ggraph** support many layout for standard used, they are: star, circle, nicely (default), dh, gem, graphopt, grid, mds, spahere, randomly, fr, kk, drl and lgl. Figures below and on the right show layouts supported by `ggraph()`.

![layout1](image/layout1.jpg) ![layout2](image/layout2.jpg)

## 5.5 Fruchterman and Reingold layout

The code chunks below will be used to plot the network graph using Fruchterman and Reingold layout.

```{r}
g <- ggraph(GAStech_graph,
            layout = "fr")+
  geom_edge_link(aes())+
  geom_node_point(aes())

g+theme_graph()
```

## 5.6 Modifying network nodes

In this section, I will colour each node by referring to their respective departments.

```{r}
g <- ggraph(GAStech_graph,
            layout = "nicely")+
  geom_edge_link(aes())+
  geom_node_point(aes(colour=Department,
                      size=3))

g+theme_graph()
```

::: {.callout-note icon="false"}
## Code Notes

1.  `geom_node_point`: is equivalent in functionality to `geo_point` of ggplot2. It allows for simple plotting of nodes in different shapes, colours and sizes. In the codes chnuks above colour and size are used.
:::

## 5.7 Modifying edges

In the code chunk below, the thickness of the edges will be mapped with the *Weight* variable.

```{r}
g <- ggraph(GAStech_graph,
            layout = "nicely")+
  geom_edge_link(aes(width=Weight),
                 alpha=0.2)+
  scale_edge_width(range = c(0.1,5))+
  geom_node_point(aes(colour=Department),
                  size=3)

g+theme_graph()
```

::: {.callout-note icon="false"}
## Code Notes

1.  `geom_edge_link`: draws edges in the simplest way - as straight lines between the start and end nodes. But, it can do more that that. In the example above, argument `width` is used to map the width of the line in proportional to the Weight attribute and argument `alpha` is used to introduce opacity on the line.
:::

# 6. Creating facet graphs

Another very useful feature of **ggraph** is faceting. In visualising network data, this technique can be used to [reduce edge over-plotting]{.underline} in a very meaning way by [spreading nodes and edges out based on their attributes]{.underline}. In this section, you will learn how to use faceting technique to visualise network data.

There are three functions in ggraph to implement faceting, they are:

-   [facet_nodes()](https://ggraph.data-imaginist.com/reference/facet_nodes.html) whereby edges are only draw in a panel if both terminal nodes are present here,
-   [facet_edges()](https://ggraph.data-imaginist.com/reference/facet_edges.html) whereby nodes are always drawn in a panels even if the node data contains an attribute named the same as the one used for the edge facetting, and
-   [facet_graph()](https://ggraph.data-imaginist.com/reference/facet_graph.html) faceting on two variables simultaneously.

## 6.1 Working with facet_edges()

In the code chunk below, `facet_edges()` is used.

```{r}
set_graph_style()

g <- ggraph(GAStech_graph,
            layout = "nicely")+
  geom_edge_link(aes(width=Weight),
                 alpha=0.2)+
  geom_node_point(aes(colour=Department),
                  size=2)

g+facet_edges(~Weekday)
```

The code chunk below uses `theme()` to change the position of the legend.

```{r}
set_graph_style()

g <- ggraph(GAStech_graph,
            layout = "nicely")+
  geom_edge_link(aes(width=Weight),
                 alpha=0.2)+
  scale_edge_width(range=c(0.1,5))+
  geom_node_point(aes(colour=Department),
                  size=2)+
  theme(legend.position = "bottom")

g+facet_edges(~Weekday)
```

## 6.2 A framed facet graph

The code chunk below adds frame to each graph.

```{r}
set_graph_style()

g <- ggraph(GAStech_graph,
            layout = "nicely")+
  geom_edge_link(aes(width=Weight),
                 alpha=0.2)+
  scale_edge_width(range = c(0.1,5))+
  geom_node_point(aes(colour=Department),
                  size=2)

g+facet_edges(~Weekday)+
  th_foreground(foreground = "grey80",
                border = TRUE)+
  theme(legend.position = "bottom")
  
```

## 6.3 Working with facet_nodes()

In the code chunk below, `facet_nodes()` is used.

```{r}
set_graph_style()

g <- ggraph(GAStech_graph,
            layout = "nicely")+
  geom_edge_link(aes(width=Weight),
                 alpha=0.2)+
  scale_edge_width(range=c(0.1,5))+
  geom_node_point(aes(colour=Department),
                  size=2)

g+facet_nodes(~Department)+
  th_foreground(foreground = "grey80",
                border = TRUE)+
  theme(legend.position = "bottom")
```

# 7. Network Metrics Analysis

## 7.1 Computing centrality indices

Centrality measures are a collection of statistical indices use to describe the relative important of the actors are to a network. There are four well-known centrality measures, namely: **degree, betweenness, closeness** and **eigenvector**.

Refer to *Chapter 7: Actor Prominence* of **A User’s Guide to Network Analysis in R*** to gain better understanding of theses network measures.

```{r}
g <- GAStech_graph %>%
  mutate(betweenness_centrality = centrality_betweenness()) %>%
  ggraph(layout = "fr") + 
  geom_edge_link(aes(width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = Department,
            size=betweenness_centrality))
g + theme_graph()
```

::: {.callout-note icon="false"}
## Code Notes

1.  `centrality_betweenness()`: the result of this function defines a property for each node which is the amount of centrality.
:::

## 7.2 Visualizing network metrics

t is important to note that from **ggraph v2.0** onward tidygraph algorithms such as centrality measures can be accessed directly in ggraph calls. This means that it is no longer necessary to precompute and store derived node and edge centrality measures on the graph in order to use them in a plot.

```{r}
g <- GAStech_graph %>%
  ggraph(layout="fr")+
  geom_edge_link(aes(width=Weight),
                 alpha=0.2)+
  scale_edge_width(range=c(0.1,5))+
  geom_node_point(aes(colour=Department,
                  size= centrality_betweenness()))

g+theme_graph()
```

## 7.3 Visualizing community

tidygraph package inherits many of the community detection algorithms imbedded into igraph and makes them available to us, including *Edge-betweenness (group_edge_betweenness), Leading eigenvector (group_leading_eigen), Fast-greedy (group_fast_greedy), Louvain (group_louvain), Walktrap (group_walktrap), Label propagation (group_label_prop), InfoMAP (group_infomap), Spinglass (group_spinglass), and Optimal (group_optimal)*. Some community algorithms are designed to take into account direction or weight, while others ignore it. 

For more about community detection, refer to [Group nodes and edges based on community structure](https://tidygraph.data-imaginist.com/reference/group_graph.html).

In the code chunk below *group_edge_betweenness()* is used.

```{r}
g <- GAStech_graph %>%
  mutate(community = as.factor(group_edge_betweenness(weights=Weight, directed=TRUE))) %>%
  ggraph(layout="fr")+
  geom_edge_link(aes(width=Weight),
                 alpha=0.2)+
  scale_edge_width(range=c(0.1,5))+
  geom_node_point(aes(colour=community))

g+theme_graph()
```

::: {.callout-note icon="false"}
## Code Notes

1.  **Edge Betweenness Centrality**: The number of times the shortest paths between all pairs of nodes pass through a particular edge. If an edge has a high betweenness centrality value, it means that many shortest paths go through this edge. In other words, this edge plays a significant role in connecting different parts of the network.

2.  **community detection algorithm (edge betweenness centrality based)**:\
  2.1  Identify the edges that connect different communities in a network. These edges often have a higher edge betweenness centrality because they lie between different communities, and many of the shortest paths connecting nodes within these communities pass through them.\
  2.2  Remove these edges.\
  2.3  More clearly reveal the different community structures within the network.
:::

# 8. Building Interactive Network Graph with visNetwork

## 8.1 Data Preparation

## 8.2 Plotting the first interactive network graph

## 8.3 Working with layout

## 8.4 Working with visual attributes - Nodes

## 8.5 Working with visual attributes - Edges

## 8.6 Interactivity

::: {.callout-note icon="false"}
## Code Notes

1.  `left_join()`: is used with `mpsz` simple feature data frame as the left data table is to ensure that the output will be a simple features data frame.
:::
